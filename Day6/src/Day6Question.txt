ğŸ”¹ What is JPA?
JPA (Java Persistence API) is a specification for ORM.
ğŸ‘‰ JPA = rules
ğŸ‘‰ Hibernate = implementation

ğŸ”¹ What is Hibernate?
Hibernate is an ORM framework that maps:
Java Object  â†”  Database Table

ğŸ”¹ Why Hibernate over JDBC? (VERY COMMON)
| JDBC             | Hibernate      |
| ---------------- | -------------- |
| Manual SQL       | Automatic ORM  |
| Boilerplate code | Less code      |
| No caching       | Caching        |
| DB dependent     | DB independent |
Hibernate reduces boilerplate code and handles ORM automatically.

ğŸ”¹ Entity Mapping (CORE)
ex.
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}

ğŸ”‘ Important Annotations
@Entity
@Id
@GeneratedValue
@Column
@Table

ğŸ”¹ Relationships (VERY IMPORTANT)
One-To-Many
ex.
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
private List<Order> orders;

| Relation   | Example           |
| ---------- | ----------------- |
| OneToOne   | User â†’ Profile    |
| OneToMany  | User â†’ Orders     |
| ManyToMany | Student â†’ Courses |

ğŸ”¹ Fetch Types (TRAP)
| Fetch | Behavior                                   |
| ----- | ------------------------------------------ |
| EAGER | Load immediately                           |
| LAZY  | Load when needed (default for collections) |
Prefer LAZY to avoid performance issues.

ğŸ”¹ Hibernate Cache
First level cache â†’ Session level
Second level cache â†’ Application level


1ï¸âƒ£ save() vs saveAndFlush()
âœ… save()
Saves entity in persistence context
Does NOT immediately hit DB
DB insert happens at transaction commit
âœ… saveAndFlush()
Saves entity AND immediately flushes to DB
Forces SQL execution instantly

ğŸ¤ Interview One-Liner
save() waits for transaction commit, saveAndFlush() forces immediate DB sync.

âš  Trap
âŒ Overusing saveAndFlush() â†’ performance issue

2ï¸âƒ£ get() vs load() (CLASSIC TRAP)
| get()                       | load()           |
| --------------------------- | ---------------- |
| Hits DB immediately         | Returns proxy    |
| Returns `null` if not found | Throws exception |
| Safe                        | Risky            |
ğŸ¤ Interview One-Liner
get() is safe and eager, load() is lazy and throws exception if entity not found.

â“ Lazy vs Eager (VERY IMPORTANT)
| Lazy                    | Eager                 |
| ----------------------- | --------------------- |
| Loaded when accessed    | Loaded immediately    |
| Better performance      | Can cause overhead    |
| Default for collections | Default for ManyToOne |
Prefer LAZY loading to avoid unnecessary DB calls.

â“ What are Cascade Types?
| Cascade Type | Meaning                  |
| ------------ | ------------------------ |
| PERSIST      | Save child with parent   |
| MERGE        | Update child with parent |
| REMOVE       | Delete child with parent |
| REFRESH      | Sync from DB             |
| DETACH       | Detach child             |
| ALL          | All of above             |
Cascade defines how parent operations affect child entities.

ğŸ”¹ OOP ROUND
â“ Diamond Problem (VERY COMMON)
â“ What is Diamond Problem?
Ambiguity caused by multiple inheritance.
    A
   / \
  B   C
   \ /
    D
âŒ Java with Classes
âŒ NOT allowed (to avoid ambiguity)
âœ… Java with Interfaces
âœ… Allowed (method implementation forced)
ğŸ¤ Interview One-Liner
Java avoids diamond problem by not supporting multiple inheritance with classes.

ğŸ§  FINAL INTERVIEW CHEAT-SHEET (MEMORIZE ğŸ”¥)
save() â†’ delayed DB hit
saveAndFlush() â†’ immediate DB hit
get() â†’ null safe
load() â†’ proxy + exception
Cascade.ALL â†’ dangerous
Lazy > Eager
Diamond problem â†’ multiple inheritance
@RestController â†’ REST APIs
@Service â†’ business logic
@RestControllerAdvice â†’ global errors


Java Collection Framework
1ï¸âƒ£ What is Collection Framework?
âœ… Definition (Interview Answer)
The Collection Framework is a set of classes and interfaces used to store, manipulate, and retrieve groups of objects dynamically.
ğŸ‘‰ Introduced in Java 1.2

2ï¸âƒ£ Why Collection Framework? (WHY NOT ARRAY)
| Array               | Collection              |
| ------------------- | ----------------------- |
| Fixed size          | Dynamic size            |
| No built-in methods | Rich APIs               |
| Primitive + Object  | Object only             |
| Manual logic        | Ready sorting/searching |
Collections are flexible, dynamic, and provide ready-made algorithms.

3ï¸âƒ£ Core Interfaces in Collection Framework
Iterable
   |
Collection
   |
--------------------------------
|              |               |
List           Set             Queue

Map (separate hierarchy)

ğŸ”¹ 4ï¸âƒ£ List Interface (ORDER + DUPLICATES)
âœ… Properties
Allows duplicate elements
Maintains insertion order
Index-based access

ğŸ”¸ ArrayList
Internal Working
Uses dynamic array
Default capacity = 10
When full â†’ new array = old * 1.5
ex.
List<Integer> list = new ArrayList<>();
list.add(10);
list.add(20);

Pros / Cons
âœ” Fast access (O(1))
âŒ Slow insertion/deletion in middle

ğŸ”¸ LinkedList
Internal Working
->Doubly linked list
->Each node stores data + prev + next
ex.
List<Integer> list = new LinkedList<>();

ğŸ”¸ Vector (LEGACY)
->Thread-safe
->Synchronized
->Slow â†’ Avoid

ğŸ“Œ List Comparison (INTERVIEW FAVORITE)
| Feature        | ArrayList     | LinkedList         |
| -------------- | ------------- | ------------------ |
| Data structure | Dynamic array | Doubly linked list |
| Access         | Fast          | Slow               |
| Insert/Delete  | Slow          | Fast               |
| Memory         | Less          | More               |

ğŸ”¹ 5ï¸âƒ£ Set Interface (UNIQUE ELEMENTS)
âœ… Properties
âŒ No duplicates
âŒ No index
Unordered (mostly)

ğŸ”¸ HashSet
Internal Working
->Uses HashMap
->Elements stored as keys
ex.
Set<String> set = new HashSet<>();
set.add("A");
set.add("A"); // ignored

âœ” Fast
âŒ No order

ğŸ”¸ LinkedHashSet
->Maintains insertion order
->Slightly slower than HashSet

ğŸ”¸ TreeSet
->Sorted order
->Uses Red-Black Tree
->O(log n)
ex.
Set<Integer> set = new TreeSet<>();
âŒ No null allowed

ğŸ“Œ Set Comparison
| Set           | Order  | Duplicate | Null |
| ------------- | ------ | --------- | ---- |
| HashSet       | âŒ      | âŒ         | 1    |
| LinkedHashSet | âœ…      | âŒ         | 1    |
| TreeSet       | Sorted | âŒ         | âŒ    |

ğŸ”¹ 6ï¸âƒ£ Map Interface (KEY â†’ VALUE)
âœ… Properties
->Key-value pair
->âŒ Duplicate keys
->Values can duplicate
->Fast searching

ğŸ”¸ HashMap (MOST USED)
Internal Working
->Uses hashing
->Buckets + linked list / tree
ex.
Map<Integer,String> map = new HashMap<>();
map.put(1,"Amit");
âœ” Fast
âœ” 1 null key, many null values

ğŸ”¸ LinkedHashMap
Maintains insertion order

ğŸ”¸ TreeMap
Sorted by key
No null key

ğŸ”¸ Hashtable (LEGACY)
Thread-safe
Slow
No null key/value

ğŸ“Œ Map Comparison (INTERVIEW GOLD)
| Map           | Order  | Null Key | Thread Safe |
| ------------- | ------ | -------- | ----------- |
| HashMap       | âŒ      | 1        | âŒ           |
| LinkedHashMap | âœ…      | 1        | âŒ           |
| TreeMap       | Sorted | âŒ        | âŒ           |
| Hashtable     | âŒ      | âŒ        | âœ…           |

ğŸ”¥ 7ï¸âƒ£ Time Complexity (VERY IMPORTANT)
| Operation | ArrayList | HashMap | HashSet |
| --------- | --------- | ------- | ------- |
| Add       | O(1)      | O(1)    | O(1)    |
| Search    | O(n)      | O(1)    | O(1)    |
| Delete    | O(n)      | O(1)    | O(1)    |

ğŸ”¥ 8ï¸âƒ£ Iterator vs ListIterator
| Iterator        | ListIterator           |
| --------------- | ---------------------- |
| Forward only    | Forward + backward     |
| All collections | List only              |
| remove()        | add(), set(), remove() |

ğŸ”¥ 9ï¸âƒ£ Comparable vs Comparator (TRAP)
Comparable
ex.
class Student implements Comparable<Student> {
    public int compareTo(Student s) {
        return Integer.compare(this.id, s.id);
    }
}

Comparator
ex.
Collections.sort(list, (a,b) -> a.name.compareTo(b.name));

| Comparable    | Comparator    |
| ------------- | ------------- |
| Natural order | Custom order  |
| Inside class  | Outside class |

ğŸ”¥ ğŸ”Ÿ Thread-Safe Collections
âŒ Avoid Vector, Hashtable
âœ… Use:
EX.
Collections.synchronizedList(list);
ConcurrentHashMap
CopyOnWriteArrayList

â“ Why HashMap faster than ArrayList?
ğŸ‘‰ Direct key access, no traversal

â“ Why TreeMap slower than HashMap?
ğŸ‘‰ Sorting overhead (O(log n))

â“ Why Map not part of Collection?
ğŸ‘‰ Different structure (key-value)

â“ When to use Set?
ğŸ‘‰ When uniqueness matters

â“ Fail-Fast vs Fail-Safe?
Fail-Fast â†’ throws ConcurrentModificationException
Fail-Safe â†’ works on copy (Concurrent collections)

ğŸ§  ONE-PAGE INTERVIEW REVISION (MEMORIZE ğŸ”¥)
List â†’ ordered + duplicate
Set â†’ unique
Map â†’ key-value
ArrayList â†’ fast access
LinkedList â†’ fast insert
HashMap â†’ fastest search
TreeMap â†’ sorted
ConcurrentHashMap â†’ thread safe


ğŸ”¥ Java 8 Stream API with Collections (IN DETAIL)
1ï¸âƒ£ What is Stream API?
âœ… Interview Answer
Stream API is used to process collections in a functional and declarative way.
ğŸ‘‰ Stream â‰  Collection
Collection â†’ stores data
Stream â†’ processes data

2ï¸âƒ£ Why Stream API? (Why not loops?)
| Loop             | Stream              |
| ---------------- | ------------------- |
| More code        | Less code           |
| Hard to read     | Clean & readable    |
| Error-prone      | Functional          |
| Manual filtering | Built-in operations |
Stream API makes data processing clean, readable, and efficient.

3ï¸âƒ£ Stream Pipeline (CORE CONCEPT)
Collection â†’ Stream â†’ Operation â†’ Result
ex.
list.stream()
    .filter()
    .map()
    .collect();

4ï¸âƒ£ Common Stream Operations (MEMORIZE)
ğŸ”¹ Intermediate Operations (Lazy)
filter()
map()
sorted()
distinct()

ğŸ”¹ Terminal Operations
forEach()
collect()
count()
findFirst()
reduce()

filter: filter() is used to select matching elements.

â“ Why Stream is lazy?
ğŸ‘‰ Intermediate operations execute only when terminal operation is called.

â“ What is Optional?
ğŸ‘‰ Wrapper to avoid NullPointerException.

â“ Can we reuse a stream?
âŒ No (stream is single-use).

â“ Parallel Stream?
ex.
employees.parallelStream()

âœ” Uses multiple threads
âŒ Use carefully (not always faster)

ğŸ§  ONE-PAGE INTERVIEW REVISION (MEMORIZE ğŸ”¥)
filter â†’ select
map â†’ transform
collect â†’ result
groupingBy â†’ classification
toMap â†’ key-value
Optional â†’ null safety


ğŸ§  INTERVIEW GOLD RULES (MEMORIZE ğŸ”¥)

âœ” Stream is single-use
âœ” filter â†’ selection
âœ” map â†’ transformation
âœ” reduce â†’ aggregation
âœ” findFirst â†’ Optional
âœ” distinct â†’ uniqueness
âœ” sorted â†’ ordering

â“ What is Optional?
âœ… Interview Answer
Optional is a container object used to avoid NullPointerException.

âš ï¸ TRAP 1: Optional.of() vs Optional.ofNullable()
Use ofNullable() when value may be null.

âš ï¸ TRAP 2: get() without checking
Never call get() without checking presence.

âš ï¸ TRAP 3: orElse() vs orElseGet() (VERY IMPORTANT)
| Method    | Behavior               |
| --------- | ---------------------- |
| orElse    | Always executes        |
| orElseGet | Executes only if empty |
Prefer orElseGet() for performance.

âš ï¸ TRAP 4: isPresent() misuse
âŒ Bad:
ex.
if(opt.isPresent()) {
    System.out.println(opt.get());
}

âœ… Good:
ex.
opt.ifPresent(System.out::println);
ifPresent() is cleaner and safer.

âš ï¸ TRAP 5: Optional as method parameter âŒ
ex.
void test(Optional<String> name) {} // âŒ bad practice
Optional is meant for return types, not parameters.

âš ï¸ TRAP 6: Optional inside entity âŒ
ex.
class User {
    Optional<String> name; // âŒ avoid
}
Do not use Optional as field type.

ğŸ§  OPTIONAL â€“ QUICK INTERVIEW REVISION
of() â†’ never null
ofNullable() â†’ safe
get() â†’ risky
orElseGet() > orElse
Use Optional in return, not fields/params

ğŸ§  STREAM PERFORMANCE â€“ QUICK INTERVIEW RULES
Prefer sequential stream by default
Use parallelStream only when needed
Avoid side effects
Filter early
Avoid blocking calls
Use correct terminal operation

ğŸ”¥ FINAL INTERVIEW ONE-LINERS (MEMORIZE)
Optional avoids null pointer exception(NPE)
ofNullable() is safe
orElseGet() is lazy
Stream is single-use
parallelStream â‰  faster always
Streams should be side-effect free